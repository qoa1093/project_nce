day3_note.txt

[조건문]
조건문을 사용해야하는 상황을 알고 조건문 사용
상황에 따라 결과가 달라질 때 조건문을 사용
~하면 ...해라
모든 조건문은 if문으로 표현가능
switch는 모든 조건을 표현할 수는 없음

[if문, switch문]

# if문(해석방법)
조건식1이 참이면 실행문1을 실행하고,
조건식1이 거짓이고 조건식2가 참이면 실행문2를 실행하고
조건식1, 조건식2가 모두 거짓이면 실행문3을 실행해라
else : 현재 위치를 기준으로 위에 있는 조건식이 거짓이면~

<if문 기본문법>

if(조건식1){
	실행문1;  
    }else if(조건식2){
    실행문2;
    }else{ 
    실행문3;
    }


1.	if(조건식)//;//{           //실수 상황 예시 : 'if문 조건식뒤에 ;'
    	실행문;
    	}
    
	= if(조건식){

		}
		실행문;               //조건상관없이 무조건 실행됨. 에러가 안나서 찾기 어려움.

2. if(num%2==0){            //실수 상황 예시2 : 'else옆에 조건식 쓰기'
 	sysout("a");
 	}else(오잉또잉 실수!){
 	sysout("d");
 	}

3.	if(조건식){            	//실수 상황 예시3 : '{}뒤에 ;'
    	실행문;
    	};


4.if(조건식){           		 //실수 상황 예시4 : '괄호닫기 } 안함'
    	실행문;


<이중 if문>

- if문의 실행문으로 if문이 또 오는 경우
- 이중 if문은 단일 if문으로도 표현할 수 있다.

if(조건식1){
	if(조건식2){
			실행문;
	}
}

= if(조건식1 && 조건식2){
		실행문;
  }

# switch문
- 사용하는 변수의 값이 제한적일때
- 산술연산 예제, 월의 마지막일 출력 예제
(해석방법)
변수가 값1과 같으면 실행문을 실행하고 스위치문을 빠져나가세요
이하 동일 반복
//@@@ break없으면 만날때까지 계속 감 오 파이썬이랑 이건 방향이 다르네?? 파이썬은 브레이크가 약간 특수상황같던데



<switch 기본문법>

switch(변수나 식){
case 값1:					--->	if(변수 == 값1)
	실행문1;
	break;
case 값2:							else if(변수 == 값2)
	실행문2;
	break;
default:							else
	실행문3;
}

//@@@ 값1을 ==를 기준으로 오른쪽 변수에 넣는것이기 때문에 스위치는 식을 나눈거라고 생각함 됨~

-예: num % 5 => 0~4 (값이 제한적으로 나오는경우 스위치문 사용)
- case 값으로는 정수형 값(0,1,2)과 문자열('0')만 가능(실수, 논리형은 x) //계산쉬우려고??
- ==로는 문자열 비교를 할 수 없음


[반복문]
- 규칙적인 작업을 반복적으로 할 때 반복문을 사용
- 규칙과 반복횟수
- for문, while문, do while문

<for문 문법>
for(1.초기화; 2.5.8.조건식; 4.7.증감연산식){
		3.6.실행문;
}

-초기화 : for문 실행시 1번만 실행(조건식이나 실행문에서 사용하는 변수를 초기화시킴)  //생략가능
-조건식 : 조건식이 참이면 반복문을 동작, 거짓이면 반복문이 종료				    //생략가능
		반복문은 조건식이 거짓이 될때까지 반복
		생략하면 조건식은 무조건 참으로 판별
-증감식 : 조건식, 실행문에서 사용하는 변수를 증가/감소시킴 				    //생략가능

(		 * 두 정수 : j, k 			//한쪽을 기준으로 1씩 증가만 체크해도 됨. 기준j보다 더 큰 공약수는 없음
		 * 반복횟수 : i는 1부터 j까지 1씩 증가 
		 * 규칙성 : i가 j의 약수이고 i가 k의 약수이면 i를 변수 gcd에 저장
		 * 			=> j를 i로 나누었을때 나머지가 0과 같고
		 * 				k를 i로 나누었을 때 나머지가 0과 같다면
		 * 				i를 변수 gcd에 저장   )






<while문 문법>



<do while문 문법>










//int num = 2147483648;    = 011111111 111111111 11111111 11111111 + 1 = 
							 100000000 000000000 00000000 00000000(overflow : 표현범위를 넘어선 숫자)
System.out.println(num + 1);
=> -로 되돌아감

int 4바이트 =32비트

int num = -2147483648;
System.out.println(num - 1);
=> +로 되돌아감(underflow)
    
    
//66p 이스케이프 문자 설명페이지